{"version":3,"sources":["../source/input control.js"],"names":["onCut","event","input","_parse","_format","on_change","setTimeout","format_input_text","undefined","onPaste","selection","erase_selection","onChange","onKeyDown","operation","preventDefault","text","value","slice","start","end","caret","operation_applied","formatted"],"mappings":"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","sourcesContent":["import edit   from './edit'\r\nimport parse  from './parse'\r\nimport format from './format'\r\n\r\nimport\r\n{\r\n\tgetOperation,\r\n\tgetSelection,\r\n\tgetCaretPosition,\r\n\tsetCaretPosition\r\n}\r\nfrom './dom'\r\n\r\nexport function onCut(event, input, _parse, _format, on_change)\r\n{\r\n\t// The actual cut hasn't happened just yet hence the timeout.\r\n\tsetTimeout(() => format_input_text(input, _parse, _format, undefined, on_change), 0)\r\n}\r\n\r\nexport function onPaste(event, input, _parse, _format, on_change)\r\n{\r\n\tconst selection = getSelection(input)\r\n\r\n\t// If selection is made,\r\n\t// just erase the selected text\r\n\t// prior to pasting\r\n\tif (selection)\r\n\t{\r\n\t\terase_selection(input, selection)\r\n\t}\r\n\r\n\tformat_input_text(input, _parse, _format, undefined, on_change)\r\n}\r\n\r\nexport function onChange(event, input, _parse, _format, on_change)\r\n{\r\n\tformat_input_text(input, _parse, _format, undefined, on_change)\r\n}\r\n\r\n// Intercepts \"Delete\" and \"Backspace\" keys.\r\n// (hitting \"Delete\" or \"Backspace\" at any caret\r\n//  position should always result in rasing a digit)\r\nexport function onKeyDown(event, input, _parse, _format, on_change)\r\n{\r\n\tconst operation = getOperation(event)\r\n\r\n\tswitch (operation)\r\n\t{\r\n\t\tcase 'Delete':\r\n\t\tcase 'Backspace':\r\n\t\t\t// Intercept this operation and perform it manually.\r\n\t\t\tevent.preventDefault()\r\n\r\n\t\t\tconst selection = getSelection(input)\r\n\r\n\t\t\t// If selection is made,\r\n\t\t\t// just erase the selected text,\r\n\t\t\t// and don't apply any more operations to it.\r\n\t\t\tif (selection)\r\n\t\t\t{\r\n\t\t\t\terase_selection(input, selection)\r\n\t\t\t\treturn format_input_text(input, _parse, _format, undefined, on_change)\r\n\t\t\t}\r\n\r\n\t\t\t// Else, perform the (character erasing) operation manually\r\n\t\t\treturn format_input_text(input, _parse, _format, operation, on_change)\r\n\r\n\t\tdefault:\r\n\t\t\t// Will be handled when `onChange` fires.\r\n\t}\r\n}\r\n\r\n/**\r\n * Erases the selected text inside an `<input/>`.\r\n * @param  {DOMElement} input\r\n * @param  {Selection} selection\r\n */\r\nfunction erase_selection(input, selection)\r\n{\r\n\tlet text = input.value\r\n\ttext = text.slice(0, selection.start) + text.slice(selection.end)\r\n\r\n\tinput.value = text\r\n\tsetCaretPosition(input, selection.start)\r\n}\r\n\r\n/**\r\n * Parses and re-formats `<input/>` textual value.\r\n * E.g. when a user enters something into the `<input/>`\r\n * that raw input must first be parsed and the re-formatted properly.\r\n * Is called either after some user input (e.g. entered a character, pasted something)\r\n * or after the user performed an `operation` (e.g. \"Backspace\", \"Delete\").\r\n * @param  {DOMElement} input\r\n * @param  {Function} parse\r\n * @param  {Function} format\r\n * @param  {string} [operation] - The operation that triggered `<input/>` textual value change. E.g. \"Backspace\", \"Delete\".\r\n * @param  {Function} onChange\r\n */\r\nfunction format_input_text(input, _parse, _format, operation, on_change)\r\n{\r\n\t// Parse `<input/>` textual value.\r\n\t// Get `value` and `caret` position.\r\n\tlet { value, caret } = parse(input.value, getCaretPosition(input), _parse)\r\n\r\n\t// If a user performed an operation (e.g. \"Backspace\", \"Delete\")\r\n\t// then apply that operation and get new `value` and `caret` position.\r\n\tif (operation)\r\n\t{\r\n\t\tconst operation_applied = edit(value, caret, operation)\r\n\r\n\t\tvalue = operation_applied.value\r\n\t\tcaret = operation_applied.caret\r\n\t}\r\n\r\n\t// Format the `value`.\r\n\t// (and reposition the caret accordingly)\r\n\tconst formatted = format(value, caret, _format)\r\n\r\n\tconst text = formatted.text\r\n\tcaret      = formatted.caret\r\n\r\n\t// Set `<input/>` textual value manually\r\n\t// to prevent React from resetting the caret position\r\n\t// later inside subsequent `render()`.\r\n\t// Doesn't work for custom `inputComponent`s for some reason.\r\n\tinput.value = text\r\n\t// Position the caret properly.\r\n\tsetCaretPosition(input, caret)\r\n\r\n\t// `<input/>` textual value may have changed,\r\n\t// so the parsed `value` may have changed too.\r\n\t// The `value` didn't neccessarily change\r\n\t// but it might have.\r\n\ton_change(value)\r\n}"],"file":"input control.js"}